package main

import (
	"fmt"
	"testing"
)

func TestX0(t *testing.T) {
	data := []byte{
		0x01, 0x11, 0x61, 0x62,
	}

	res := parseRecord(data)

	fmt.Println(res)
	t.Errorf("eee")
}

func TestXxx(t *testing.T) {

	// 		  Record header
	// 07     Size of record header (varint): 7

	// 17     Serial type for sqlite_schema.type (varint):     23
	//        Size of sqlite_schema.type =                     (23-13)/2 = 5

	// 1b     Serial type for sqlite_schema.name (varint):     27
	//        Size of sqlite_schema.name =                     (27-13)/2 = 7

	// 1b     Serial type for sqlite_schema.tbl_name (varint): 27
	//        Size of sqlite_schema.tbl_name =                 (27-13)/2 = 7

	// 01     Serial type for sqlite_schema.rootpage (varint): 1
	//        8-bit twos-complement integer

	// 81 47  Serial type for sqlite_schema.sql (varint):      199
	//        Size of sqlite_schema.sql =                      (199-13)/2 = 93

	// CREATE TABLE sqlite_schema(
	//   type text,
	//   name text,
	//   tbl_name text,
	//   rootpage integer,
	//   sql text
	// );

	// Record body
	// 74 61 62 6c 65        Value of sqlite_schema.type:     "table"
	// 6f 72 61 6e 67 65 73  Value of sqlite_schema.name:     "oranges"
	// 6f 72 61 6e 67 65 73  Value of sqlite_schema.tbl_name: "oranges"

	// 04 -> 4 root page number (where data for this table is stored, entry point to it)

	// 43 52 45 41 54 45 20 54  41 42 4c 45 20 6f 72 61
	// 6e 67 65 73											   "CREATE TABLE oranges"

	// 0a - new line
	// 09 - tab char

	// 0a 28 0a 09  69 64 20 69 6e 74 65 67
	// 65 72 20 70 72 69 6d 61  72 79 20 6b 65 79 20 61  		"(
	// 75 74 6f 69 6e 63 72 65  6d 65 6e 74 2c 0a 09 6e  			id integer primary key autoincrement,
	// 61 6d 65 20 74 65 78 74  2c 0a 09 64 65 73 63 72  			name text,
	// 69 70 74 69 6f 6e 20 74  65 78 74 0a 29                   	description text
	//															  )"

	data := []byte{
		0x07, 0x17, 0x1b, 0x1b, 0x01, 0x81,
		0x47, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x6f, 0x72,
		0x61, 0x6e, 0x67, 0x65, 0x73, 0x6f, 0x72, 0x61,
		0x6e, 0x67, 0x65, 0x73, 0x04, 0x43, 0x52, 0x45,
		0x41, 0x54, 0x45, 0x20, 0x54, 0x41, 0x42, 0x4c,
		0x45, 0x20, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65,
		0x73, 0x0a, 0x28, 0x0a, 0x09, 0x69, 0x64, 0x20,
		0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20,
		0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20,
		0x6b, 0x65, 0x79, 0x20, 0x61, 0x75, 0x74, 0x6f,
		0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
		0x74, 0x2c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65,
		0x20, 0x74, 0x65, 0x78, 0x74, 0x2c, 0x0a, 0x09,
		0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
		0x69, 0x6f, 0x6e, 0x20, 0x74, 0x65, 0x78, 0x74,
		0x0a, 0x29,
	}

	res := parseRecord(data)

	fmt.Println(res)
	for _, item := range res {
		switch aa := item.(type) {
		case []byte:
			fmt.Println(string(aa))
		}

	}
	t.Errorf("eee")
}

func TestAA(t *testing.T) {

	data := []byte{
		0x78, 0x03, 0x07, 0x17, 0x1b, 0x1b, 0x01, 0x81,
		0x47, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x6f, 0x72,
		0x61, 0x6e, 0x67, 0x65, 0x73, 0x6f, 0x72, 0x61,
		0x6e, 0x67, 0x65, 0x73, 0x04, 0x43, 0x52, 0x45,
		0x41, 0x54, 0x45, 0x20, 0x54, 0x41, 0x42, 0x4c,
		0x45, 0x20, 0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65,
		0x73, 0x0a, 0x28, 0x0a, 0x09, 0x69, 0x64, 0x20,
		0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20,
		0x70, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20,
		0x6b, 0x65, 0x79, 0x20, 0x61, 0x75, 0x74, 0x6f,
		0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
		0x74, 0x2c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65,
		0x20, 0x74, 0x65, 0x78, 0x74, 0x2c, 0x0a, 0x09,
		0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
		0x69, 0x6f, 0x6e, 0x20, 0x74, 0x65, 0x78, 0x74,
		0x0a, 0x29, 0x0, 0x0, 0x0, 0x0,
		// 10 41
	}
	fmt.Println(len(data))
	schema, _ := parseDataBaseSchema(data)

	fmt.Println(schema)
	t.Error("fd")
}
